오늘 Big-O에 대해서 배웠는데 이를 통해서 시간 복잡도를 해결하는 것이 결국 알고리즘을 잘푸는 방법이라는 것을 배웠다.
알고리즘에는 시간과 공간의 제약을 받기 때문에 결국 데이터가 커지면 시간이 커질 수 밖에 없기 때문에 이를 처리하는 방법이 중요하다.


아래는 오늘 배운 개념이다.

O(1) - 실행시간 일정, 평생 알고리즘을 풀 수 있는 리스크가 존재
O(log n) - 실행시간이 입력값에 의해 영향을 받음, 웬만한 n의 크기에 대해서 매우 견고
O(n) - 비례해서 시간의 영향을 받음, 정렬되지 않은 리스트에서 최댓값, 최솟값 찾는 경우에 해당
O(nlog n) - 병합 정렬을 비롯한 대부분의 효율 좋은 정렬 알고리즘
O(n^2) - 버블 정렬과 같은 비효율적인 정렬 알고리즘에 해당
O(2^n) - 피보나치 수와 같은 잭귀로 계산하는 알고리즘,
O(n!) - 가장 짧은 경로를 찾을 때나 부르트 포스를 풀 때 해당, 가장 느린 알고리즘 팩토리얼이 굉장히 큰 값이기 때문이다.

가장 늦게 실행될 때(상한) : 빅오
가장 빠르게 실행 될때(하한) : 빅오메가
평균 : 빅세타
